---
title: Measuring field usage in Apollo Studio
sidebar_title: Field usage
description: Understand which fields your clients use
---

import { CodeColumns } from "gatsby-theme-apollo-docs";

In Apollo Studio, your graph's **Fields** page can display a table of usage metrics for each field in your schema. For example, here are metrics for the fields of a `BuildError` type:

<img
  src="../img/fields-page.jpg"
  class="screenshot"
  alt="Fields page in Studio"
  width="700"
/>

You can click any field in the table to view details about which clients and operations contribute to its usage.

The table displays some combination of the following metrics for each field, depending on what data is available:

| Metric                 | Description                                                                                                                          |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| Field executions       | How many times your servers have executed the resolver for the field over a given time period.                                       |
| Referencing operations | How many operations sent by clients over a given time period have included the field, according to metrics provided by your servers. |

For each of these columns to appear on the Fields page, your GraphQL servers must report the associated metrics to Apollo Studio. If some but not _all_ of your GraphQL servers report this data, the Fields page presents an incomplete picture of your graph's field usage.

## Field executions vs. referencing operations

Let's look at the example metrics for the `BuildError` type again:

<img
  src="../img/fields-page.jpg"
  class="screenshot"
  alt="Fields page in Studio"
  width="700"
/>

As you can see, the daily **field executions** and **referencing operations** for a single field can differ significantly! There are many possible reasons for this, described below.

### Objects in lists

Let's say a client executes the following query one time:

```graphql
query GetBooks {
  books {
    title
  }
}
```

If `Query.books` returns a list of ten `Book` objects, then `Book.title` is resolved _ten times_. This query therefore contributes _ten_ **field executions** and just _one_ **referencing operation** to `Book.title`.

### Multiple references to a field

Let's say a client executes the following query one time:

```
graphql
query GetTwoBooks {
  firstBook: book(id: "123") {
    title
  }
  secondBook: book(id: "345") {
    title
  }
}
```

This operation contains two textual references to the fields `Query.book` and `Book.title`, and (assuming `Query.book` doesn't return `null`) each field is thus executed twice. So this will count as 2 towards the "field executions" statistic for each field. However, Apollo Studio will consider this to just be a single "referencing operation" for each field, as it is counting operations rather than references within operations.

### Fields that return interfaces

Let's say our GraphQL server's schema defines the following interface and object types:

```graphql
interface Media {
  title: String!
}

type Book implements Media {
  title: String!
  author: String!
}

type Query {
  favoriteMedia: Media!
}
```

Now, let's say a client executes the following query:

```graphql
query GetFavoriteMedia {
  favoriteMedia {
    title
  }
}
```

If `Query.favoriteMedia` returns a `Book` object here, then `Book.title` is resolved one time. _However_, the original query _does not reference_ `Book.title`. Instead, it references **`Media.title`**, because `Query.favoriteMedia` has a return type of `Media`.

Therefore, this query contributes one **field execution** and zero **referencing operations** to `Book.title`. It also contributes one **referencing operation** to `Media.title`; interface fields always have zero **field executions**.

### Referenced fields that aren't resolved

Let's say a client executes the following query one time:

```graphql
query GetLoggedInUser {
  loggedInUser {
    name
  }
}
```

Now, let's say `Query.loggedInUser` returns `null` because no user is logged in. In this case, the resolver for `User.name` never executes, because its parent retuns `null`. Therefore, this query contributes _zero_ **field executions** and _one_ **referencing operation** to `User.name`.

A referenced field might not be resolved for any of these reasons:

- The field is nested under a field which returns `null`, as shown above.
- The field is nested under a field which returns a list, but the list is empty.
- The field is part of a fragment that doesn't apply to a particular object.
- The resolver is skipped due to a `@skip` or `@include` directive.

### `@key` and `@requires` fields in a federated graph

> This case applies only to graphs that use [Apollo Federation](https://www.apollographql.com/docs/federation).

Let's say our federated graph includes these two subgraph schemas:

<CodeColumns>

```graphql
# Products subgraph

type Product @key(fields: "id") {
  id: ID!
  name: String!
}
```

```graphql
# Reviews subgraph

extend type Product @key(fields: "id") {
  id: ID! @external
}

type Review {
  id: ID!
  score: Int!
  product: Product!
}

type Query {
  reviews: [Review!]!
}
```

</CodeColumns>

Now, let's say a client executes the following query against the gateway:

```graphql
query GetAllReviews {
  reviews {
    score
    product {
      name
    }
  }
}
```

This query's execution starts in the Reviews subgraph, but it needs to obtain each `Product`'s `name` from the Products subgraph. As part of this process, the Products subgraph must [resolve references](https://www.apollographql.com/docs/federation/entities/#resolving) to `Product`s that are provided by the Reviews subgraph.

To help resolve these references, the Reviews subgraph _must_ return each `Product`'s `id` field, even though that field isn't included in the original query. This is because `id` is a `@key` field for `Product`.

Therefore, this query contributes one **field execution** and zero **referencing operations** to `Product.id`. Similar logic applies to fields that use the [`@requires` directive](https://www.apollographql.com/docs/federation/entities/#extending-an-entity-with-computed-fields-advanced).

## Sending field usage data

Your GraphQL server may be set up to send only field execution statistics, only referencing operation statistics, or both. (This document explains how to configure an Apollo Server to talk to Studio, including an Apollo Server with Apollo Gateway in front of GraphQL servers from any platform.)

In order to report referencing operation statistics, your server must be running Apollo Server 3.6Â or newer. If your graph is federated, there are no specific requirements for your subgraphs in order to support referencing operation statistics.

There are no specific requirements in order to report field execution statistics from a non-federated Apollo Server. To report field execution statistics from an Apollo Gateway, your subgraphs must support federated tracing; these are the server libraries listed with "FTV1" in [the subgraph-compatible library list](https://www.apollographql.com/docs/federation/other-servers/). If some of your subgraphs support federated tracing and others do not, field executions in subgraphs that do not support federated tracing will not contribute to statistics.

Calculating field execution statistics can potentially have performance impacts on large queries and high-traffic graphs. This is especially the case for federated graphs, because field execution statistics are currently transmitted from subgraphs to federated graphs in the form of detailed execution traces inside the body of the response from the subgraph to the Gateway. Starting with Apollo Server 3.6, you can disable field-level instrumentation for some or all operations via the [`fieldLevelInstrumentation` option to `ApolloServerPluginUsageReporting`](https://apollographql.com/docs/apollo-server/api/plugin/usage-reporting/#fieldlevelinstrumentation).

Disabling field-level instrumentation for a particular request has three effects:

- The request does not contribute to the "field executions" statistic on the Fields page.
- The request does not contribute to field-level execution timing hints that can be optionally displayed in Studio Explorer and in vscode-graphql.
- The request does not produce a trace that can be viewed on the Traces section of the Operations page.

These requests _will_ still contribute to most features of Studio, such as schema checks, the Operations page, and the "referencing operations" statistic on the Fields page.

To disable field-level instrumentation for all requests, pass `() => false` as the `fieldLevelInstrumentation` option:

```ts
new ApolloServer({
  plugins: [
    ApolloServerPluginUsageReporting({
      fieldLevelInstrumentation: () => false,
    }),
  ],
  // ...
});
```

If you do this, field execution statistics will not appear on the Fields page.

You can also enable field-level instrumentation for a fixed fraction of all requests by passing a number between 0 and 1 as the `fieldLevelInstrumentation` option. (Be careful to pass _a number_ like `0.01`, not _a function returning a number_ like `() => 0.01`, which will have a different effect.) If you pass a number, your server will randomly choose to enable field-level instrumentation on each request with the given probability. Additionally, when a request is chosen for field-level instrumentation, your server will report it to Apollo Studio with a weight based on the given probability. The fields execution statistic on the Fields page (as well as execution timing hints) will be scaled by this weight. So for example, if you pass `0.01`, your server will enable field-level execution on 1% of requests, and every observed field execution will count as 100 field executions on the Fields page. (The actual observed execution count is available in a tooltip in the table.)

You can also decide whether or not to enable field-level instrumentation (and what the weight should be) on a per-operation basis by passing a function for `fieldLevelInstrumentation`. For example, you may want to enable field-level instrumentation more often for rare operations and less often for common operations. See the [usage reporting plugin docs](https://apollographql.com/docs/apollo-server/api/plugin/usage-reporting/#fieldlevelinstrumentation) for more details.
